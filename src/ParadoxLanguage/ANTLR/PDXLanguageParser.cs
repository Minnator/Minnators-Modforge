////------------------------------------------------------------------------------
//// <auto-generated>
////     This code was generated by a tool.
////     ANTLR Version: 4.13.1
////
////     Changes to this file may cause incorrect behavior and will be lost if
////     the code is regenerated.
//// </auto-generated>
////------------------------------------------------------------------------------

//// Generated from d:/EU4 Grammar/PDXLanguageParser.g4 by ANTLR 4.13.1

//// Unreachable code detected
//#pragma warning disable 0162
//// The variable '...' is assigned but its value is never used
//#pragma warning disable 0219
//// Missing XML comment for publicly visible type or member '...'
//#pragma warning disable 1591
//// Ambiguous reference in cref attribute
//#pragma warning disable 419

//using System;
//using System.IO;
//using System.Text;
//using System.Diagnostics;
//using System.Collections.Generic;
//using Antlr4.Runtime;
//using Antlr4.Runtime.Atn;
//using Antlr4.Runtime.Misc;
//using Antlr4.Runtime.Tree;
//using DFA = Antlr4.Runtime.Dfa.DFA;

//[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.1")]
//[System.CLSCompliant(false)]
//public partial class PDXLanguageParser : Parser {
//	protected static DFA[] decisionToDFA;
//	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
//	public const int
//		WHITESPACE=1, SINGLE_LINE_COMMENT=2, EQ=3, LPAR=4, RPAR=5, AND=6, OR=7, 
//		YES=8, NO=9, NOT=10, INT=11, MPOWER=12, TAG=13, STRING=14, FLOAT=15, DATE=16, 
//		MONTHS=17, DAYS=18, COLOR=19, PLUS=20, MINUS=21, COMMA=22, DOT=23, IF=24, 
//		ELSE=25, ELSE_IF=26, LIMIT=27, WHILE=28, IDENTIFIER=29, STRING_TOOLTIP=30;
//	public const int
//		RULE_areaFile = 0, RULE_intList = 1, RULE_color = 2, RULE_area = 3, RULE_rpar = 4;
//	public static readonly string[] ruleNames = {
//		"areaFile", "intList", "color", "area", "rpar"
//	};

//	private static readonly string[] _LiteralNames = {
//		null, null, null, "'='", "'{'", "'}'", "'AND'", "'OR'", null, null, null, 
//		null, null, null, null, null, null, "'months'", "'days'", "'color'", "'+'", 
//		"'-'", "','", "'.'", "'if'", "'else'", "'else_if'", "'limit'", "'while'"
//	};
//	private static readonly string[] _SymbolicNames = {
//		null, "WHITESPACE", "SINGLE_LINE_COMMENT", "EQ", "LPAR", "RPAR", "AND", 
//		"OR", "YES", "NO", "NOT", "INT", "MPOWER", "TAG", "STRING", "FLOAT", "DATE", 
//		"MONTHS", "DAYS", "COLOR", "PLUS", "MINUS", "COMMA", "DOT", "IF", "ELSE", 
//		"ELSE_IF", "LIMIT", "WHILE", "IDENTIFIER", "STRING_TOOLTIP"
//	};
//	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

//	[NotNull]
//	public override IVocabulary Vocabulary
//	{
//		get
//		{
//			return DefaultVocabulary;
//		}
//	}

//	public override string GrammarFileName { get { return "PDXLanguageParser.g4"; } }

//	public override string[] RuleNames { get { return ruleNames; } }

//	public override int[] SerializedAtn { get { return _serializedATN; } }

//	static PDXLanguageParser() {
//		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
//		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
//			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
//		}
//	}

//		public PDXLanguageParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

//		public PDXLanguageParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
//		: base(input, output, errorOutput)
//	{
//		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
//	}

//	public partial class AreaFileContext : ParserRuleContext {
//		[System.Diagnostics.DebuggerNonUserCode] public AreaContext[] area() {
//			return GetRuleContexts<AreaContext>();
//		}
//		[System.Diagnostics.DebuggerNonUserCode] public AreaContext area(int i) {
//			return GetRuleContext<AreaContext>(i);
//		}
//		public AreaFileContext(ParserRuleContext parent, int invokingState)
//			: base(parent, invokingState)
//		{
//		}
//		public override int RuleIndex { get { return RULE_areaFile; } }
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override void EnterRule(IParseTreeListener listener) {
//			IPDXLanguageParserListener typedListener = listener as IPDXLanguageParserListener;
//			if (typedListener != null) typedListener.EnterAreaFile(this);
//		}
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override void ExitRule(IParseTreeListener listener) {
//			IPDXLanguageParserListener typedListener = listener as IPDXLanguageParserListener;
//			if (typedListener != null) typedListener.ExitAreaFile(this);
//		}
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
//			IPDXLanguageParserVisitor<TResult> typedVisitor = visitor as IPDXLanguageParserVisitor<TResult>;
//			if (typedVisitor != null) return typedVisitor.VisitAreaFile(this);
//			else return visitor.VisitChildren(this);
//		}
//	}

//	[RuleVersion(0)]
//	public AreaFileContext areaFile() {
//		AreaFileContext _localctx = new AreaFileContext(Context, State);
//		EnterRule(_localctx, 0, RULE_areaFile);
//		int _la;
//		try {
//			EnterOuterAlt(_localctx, 1);
//			{
//			State = 13;
//			ErrorHandler.Sync(this);
//			_la = TokenStream.LA(1);
//			while (_la==IDENTIFIER) {
//				{
//				{
//				State = 10;
//				area();
//				}
//				}
//				State = 15;
//				ErrorHandler.Sync(this);
//				_la = TokenStream.LA(1);
//			}
//			}
//		}
//		catch (RecognitionException re) {
//			_localctx.exception = re;
//			ErrorHandler.ReportError(this, re);
//			ErrorHandler.Recover(this, re);
//		}
//		finally {
//			ExitRule();
//		}
//		return _localctx;
//	}

//	public partial class IntListContext : ParserRuleContext {
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] INT() { return GetTokens(PDXLanguageParser.INT); }
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT(int i) {
//			return GetToken(PDXLanguageParser.INT, i);
//		}
//		[System.Diagnostics.DebuggerNonUserCode] public ColorContext[] color() {
//			return GetRuleContexts<ColorContext>();
//		}
//		[System.Diagnostics.DebuggerNonUserCode] public ColorContext color(int i) {
//			return GetRuleContext<ColorContext>(i);
//		}
//		public IntListContext(ParserRuleContext parent, int invokingState)
//			: base(parent, invokingState)
//		{
//		}
//		public override int RuleIndex { get { return RULE_intList; } }
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override void EnterRule(IParseTreeListener listener) {
//			IPDXLanguageParserListener typedListener = listener as IPDXLanguageParserListener;
//			if (typedListener != null) typedListener.EnterIntList(this);
//		}
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override void ExitRule(IParseTreeListener listener) {
//			IPDXLanguageParserListener typedListener = listener as IPDXLanguageParserListener;
//			if (typedListener != null) typedListener.ExitIntList(this);
//		}
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
//			IPDXLanguageParserVisitor<TResult> typedVisitor = visitor as IPDXLanguageParserVisitor<TResult>;
//			if (typedVisitor != null) return typedVisitor.VisitIntList(this);
//			else return visitor.VisitChildren(this);
//		}
//	}

//	[RuleVersion(0)]
//	public IntListContext intList() {
//		IntListContext _localctx = new IntListContext(Context, State);
//		EnterRule(_localctx, 2, RULE_intList);
//		int _la;
//		try {
//			EnterOuterAlt(_localctx, 1);
//			{
//			State = 18;
//			ErrorHandler.Sync(this);
//			_la = TokenStream.LA(1);
//			do {
//				{
//				State = 18;
//				ErrorHandler.Sync(this);
//				switch (TokenStream.LA(1)) {
//				case INT:
//					{
//					State = 16;
//					Match(INT);
//					}
//					break;
//				case COLOR:
//					{
//					State = 17;
//					color();
//					}
//					break;
//				default:
//					throw new NoViableAltException(this);
//				}
//				}
//				State = 20;
//				ErrorHandler.Sync(this);
//				_la = TokenStream.LA(1);
//			} while ( _la==INT || _la==COLOR );
//			}
//		}
//		catch (RecognitionException re) {
//			_localctx.exception = re;
//			ErrorHandler.ReportError(this, re);
//			ErrorHandler.Recover(this, re);
//		}
//		finally {
//			ExitRule();
//		}
//		return _localctx;
//	}

//	public partial class ColorContext : ParserRuleContext {
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLOR() { return GetToken(PDXLanguageParser.COLOR, 0); }
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(PDXLanguageParser.EQ, 0); }
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAR() { return GetToken(PDXLanguageParser.LPAR, 0); }
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] INT() { return GetTokens(PDXLanguageParser.INT); }
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT(int i) {
//			return GetToken(PDXLanguageParser.INT, i);
//		}
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAR() { return GetToken(PDXLanguageParser.RPAR, 0); }
//		public ColorContext(ParserRuleContext parent, int invokingState)
//			: base(parent, invokingState)
//		{
//		}
//		public override int RuleIndex { get { return RULE_color; } }
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override void EnterRule(IParseTreeListener listener) {
//			IPDXLanguageParserListener typedListener = listener as IPDXLanguageParserListener;
//			if (typedListener != null) typedListener.EnterColor(this);
//		}
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override void ExitRule(IParseTreeListener listener) {
//			IPDXLanguageParserListener typedListener = listener as IPDXLanguageParserListener;
//			if (typedListener != null) typedListener.ExitColor(this);
//		}
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
//			IPDXLanguageParserVisitor<TResult> typedVisitor = visitor as IPDXLanguageParserVisitor<TResult>;
//			if (typedVisitor != null) return typedVisitor.VisitColor(this);
//			else return visitor.VisitChildren(this);
//		}
//	}

//	[RuleVersion(0)]
//	public ColorContext color() {
//		ColorContext _localctx = new ColorContext(Context, State);
//		EnterRule(_localctx, 4, RULE_color);
//		try {
//			EnterOuterAlt(_localctx, 1);
//			{
//			State = 22;
//			Match(COLOR);
//			State = 23;
//			Match(EQ);
//			State = 24;
//			Match(LPAR);
//			State = 25;
//			Match(INT);
//			State = 26;
//			Match(INT);
//			State = 27;
//			Match(INT);
//			State = 28;
//			Match(RPAR);
//			}
//		}
//		catch (RecognitionException re) {
//			_localctx.exception = re;
//			ErrorHandler.ReportError(this, re);
//			ErrorHandler.Recover(this, re);
//		}
//		finally {
//			ExitRule();
//		}
//		return _localctx;
//	}

//	public partial class AreaContext : ParserRuleContext {
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(PDXLanguageParser.IDENTIFIER, 0); }
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(PDXLanguageParser.EQ, 0); }
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAR() { return GetToken(PDXLanguageParser.LPAR, 0); }
//		[System.Diagnostics.DebuggerNonUserCode] public RparContext rpar() {
//			return GetRuleContext<RparContext>(0);
//		}
//		[System.Diagnostics.DebuggerNonUserCode] public IntListContext intList() {
//			return GetRuleContext<IntListContext>(0);
//		}
//		public AreaContext(ParserRuleContext parent, int invokingState)
//			: base(parent, invokingState)
//		{
//		}
//		public override int RuleIndex { get { return RULE_area; } }
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override void EnterRule(IParseTreeListener listener) {
//			IPDXLanguageParserListener typedListener = listener as IPDXLanguageParserListener;
//			if (typedListener != null) typedListener.EnterArea(this);
//		}
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override void ExitRule(IParseTreeListener listener) {
//			IPDXLanguageParserListener typedListener = listener as IPDXLanguageParserListener;
//			if (typedListener != null) typedListener.ExitArea(this);
//		}
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
//			IPDXLanguageParserVisitor<TResult> typedVisitor = visitor as IPDXLanguageParserVisitor<TResult>;
//			if (typedVisitor != null) return typedVisitor.VisitArea(this);
//			else return visitor.VisitChildren(this);
//		}
//	}

//	[RuleVersion(0)]
//	public AreaContext area() {
//		AreaContext _localctx = new AreaContext(Context, State);
//		EnterRule(_localctx, 6, RULE_area);
//		int _la;
//		try {
//			EnterOuterAlt(_localctx, 1);
//			{
//			State = 30;
//			Match(IDENTIFIER);
//			State = 31;
//			Match(EQ);
//			State = 32;
//			Match(LPAR);
//			State = 34;
//			ErrorHandler.Sync(this);
//			_la = TokenStream.LA(1);
//			if (_la==INT || _la==COLOR) {
//				{
//				State = 33;
//				intList();
//				}
//			}

//			State = 36;
//			rpar();
//			}
//		}
//		catch (RecognitionException re) {
//			_localctx.exception = re;
//			ErrorHandler.ReportError(this, re);
//			ErrorHandler.Recover(this, re);
//		}
//		finally {
//			ExitRule();
//		}
//		return _localctx;
//	}

//	public partial class RparContext : ParserRuleContext {
//		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAR() { return GetToken(PDXLanguageParser.RPAR, 0); }
//		public RparContext(ParserRuleContext parent, int invokingState)
//			: base(parent, invokingState)
//		{
//		}
//		public override int RuleIndex { get { return RULE_rpar; } }
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override void EnterRule(IParseTreeListener listener) {
//			IPDXLanguageParserListener typedListener = listener as IPDXLanguageParserListener;
//			if (typedListener != null) typedListener.EnterRpar(this);
//		}
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override void ExitRule(IParseTreeListener listener) {
//			IPDXLanguageParserListener typedListener = listener as IPDXLanguageParserListener;
//			if (typedListener != null) typedListener.ExitRpar(this);
//		}
//		[System.Diagnostics.DebuggerNonUserCode]
//		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
//			IPDXLanguageParserVisitor<TResult> typedVisitor = visitor as IPDXLanguageParserVisitor<TResult>;
//			if (typedVisitor != null) return typedVisitor.VisitRpar(this);
//			else return visitor.VisitChildren(this);
//		}
//	}

//	[RuleVersion(0)]
//	public RparContext rpar() {
//		RparContext _localctx = new RparContext(Context, State);
//		EnterRule(_localctx, 8, RULE_rpar);
//		try {
//			EnterOuterAlt(_localctx, 1);
//			{
//			State = 40;
//			ErrorHandler.Sync(this);
//			switch (TokenStream.LA(1)) {
//			case RPAR:
//				{
//				State = 38;
//				Match(RPAR);
//				}
//				break;
//			case Eof:
//			case IDENTIFIER:
//				{
//				 NotifyErrorListeners("Missing closing '}'"); 
//				}
//				break;
//			default:
//				throw new NoViableAltException(this);
//			}
//			}
//		}
//		catch (RecognitionException re) {
//			_localctx.exception = re;
//			ErrorHandler.ReportError(this, re);
//			ErrorHandler.Recover(this, re);
//		}
//		finally {
//			ExitRule();
//		}
//		return _localctx;
//	}

//	private static int[] _serializedATN = {
//		4,1,30,43,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,1,0,5,0,12,8,0,10,0,
//		12,0,15,9,0,1,1,1,1,4,1,19,8,1,11,1,12,1,20,1,2,1,2,1,2,1,2,1,2,1,2,1,
//		2,1,2,1,3,1,3,1,3,1,3,3,3,35,8,3,1,3,1,3,1,4,1,4,3,4,41,8,4,1,4,0,0,5,
//		0,2,4,6,8,0,0,42,0,13,1,0,0,0,2,18,1,0,0,0,4,22,1,0,0,0,6,30,1,0,0,0,8,
//		40,1,0,0,0,10,12,3,6,3,0,11,10,1,0,0,0,12,15,1,0,0,0,13,11,1,0,0,0,13,
//		14,1,0,0,0,14,1,1,0,0,0,15,13,1,0,0,0,16,19,5,11,0,0,17,19,3,4,2,0,18,
//		16,1,0,0,0,18,17,1,0,0,0,19,20,1,0,0,0,20,18,1,0,0,0,20,21,1,0,0,0,21,
//		3,1,0,0,0,22,23,5,19,0,0,23,24,5,3,0,0,24,25,5,4,0,0,25,26,5,11,0,0,26,
//		27,5,11,0,0,27,28,5,11,0,0,28,29,5,5,0,0,29,5,1,0,0,0,30,31,5,29,0,0,31,
//		32,5,3,0,0,32,34,5,4,0,0,33,35,3,2,1,0,34,33,1,0,0,0,34,35,1,0,0,0,35,
//		36,1,0,0,0,36,37,3,8,4,0,37,7,1,0,0,0,38,41,5,5,0,0,39,41,6,4,-1,0,40,
//		38,1,0,0,0,40,39,1,0,0,0,41,9,1,0,0,0,5,13,18,20,34,40
//	};

//	public static readonly ATN _ATN =
//		new ATNDeserializer().Deserialize(_serializedATN);


//}
